package fn

import (
	"errors"
	"time"

	"github.com/inngest/inngest/pkg/enums"
)

// ServableFunction defines a function which can be called by a handler's Serve method.
//
// This is created via CreateFunction in this package.
type ServableFunction interface {
	FullyQualifiedID() string

	ID() string

	// Name returns the function name.
	Name() string

	Config() FunctionOpts

	// Trigger returns the event name or schedule that triggers the function.
	Trigger() Trigger

	// ZeroEvent returns the zero event type to marshal the event into, given an
	// event name.
	ZeroEvent() any

	// Func returns the SDK function to call.  This must alawys be of type SDKFunction,
	// but has an any type as we register many functions of different types into a
	// type-agnostic handler; this is a generic implementation detail, unfortunately.
	Func() any
}

type FunctionOpts struct {
	// ID is an optional function ID.  If not specified, the ID
	// will be auto-generated by lowercasing and slugging the name.
	ID string
	// Name represents a human-readable function name.
	Name string

	Priority    *Priority
	Concurrency []Concurrency
	Idempotency *string
	Retries     *int
	Cancel      []Cancel
	Debounce    *Debounce
	// Timeouts represents timeouts for a function.
	Timeouts *Timeouts
	// Throttle represents a soft rate limit for gating function starts.  Any function runs
	// over the throttle period will be enqueued in the backlog to run at the next available
	// time.
	Throttle *Throttle
	// RateLimit allows specifying custom rate limiting for the function.  A RateLimit is
	// hard rate limiting:  any function invocations over the rate limit will be ignored and
	// will never run.
	RateLimit *RateLimit
	// BatchEvents represents batching
	BatchEvents *EventBatchConfig
}

func (f FunctionOpts) Validate() error {
	var err error
	if f.ID == "" {
		err = errors.Join(err, errors.New("id is required"))
	}
	return err
}

// This file copies and exports types from github.com/inngest/inngest/pkg/inngest,
// such that we don't have a bunch of unnecessary vendor imports from using this
// package.

// Trigger represents either an event trigger or a cron trigger.  Only one is valid;  when
// defining a function within Cue we enforce that only an event or cron field can be specified.
type Trigger struct {
	*EventTrigger
	*CronTrigger
}

// EventTrigger is a trigger which invokes the function each time a specific event is received.
type EventTrigger struct {
	// Event is the event name which triggers the function.
	Event string `json:"event"`

	// Expression is an optional expression which must evaluate to true for the function
	// to run.
	Expression *string `json:"expression,omitempty"`
}

// CronTrigger is a trigger which invokes the function on a CRON schedule.
type CronTrigger struct {
	Cron string `json:"cron"`
}

type Priority struct {
	Run *string `json:"run"`
}

// Concurrency represents a single concurrency limit for a function.
type Concurrency struct {
	Limit int                    `json:"limit"`
	Key   *string                `json:"key,omitempty"`
	Scope enums.ConcurrencyScope `json:"scope"`
	Hash  string                 `json:"hash"`
}

// Cancel represents a cancellation signal for a function.  When specified, this
// will set up pauses which automatically cancel the function based off of matching
// events and expressions.
type Cancel struct {
	Event   string  `json:"event"`
	Timeout *string `json:"timeout,omitempty"`
	If      *string `json:"if,omitempty"`
}

// EventBatchConfig represents how a function would expect
// a list of events to look like for consumption
//
// A batch of events will be invoked if one of the following
// is fulfilled
// - The batch is full
// - The time to wait is up
type EventBatchConfig struct {
	Key *string `json:"key,omitempty"`

	// MaxSize is the maximum number of events that can be
	// included in a batch
	MaxSize int `json:"maxSize"`

	// Timeout is the maximum number of time the batch will
	// wait before being consumed.
	Timeout string `json:"timeout"`
}

// Debounce represents debounce configuration used when creating a new function within
// FunctionOpts
type Debounce struct {
	// Key is an optional expression to use for constraining the debounce to a given
	// value.
	Key string `json:"key,omitempty"`
	// Period is how long to listen for new events matching the optional key.  Any event
	// received during this period will reschedule the debounce to run after another period
	// interval.
	Period time.Duration `json:"period"`
	// Timeout specifies the optional max lifetime of a debounce, ensuring that functions
	// run after the given duration when a debounce is rescheduled indefinitely.
	Timeout *time.Duration `json:"timeout,omitempty"`
}

// Throttle represents concurrency over time.
type Throttle struct {
	// Limit is how often the function can be called within the specified period.  The
	// minimum limit is 1.
	Limit uint `json:"limit"`
	// Period represents the time period for throttling the function.  The minimum
	// granularity is 1 second.  Run starts are spaced evenly through the given period.
	Period time.Duration `json:"period"`
	// Burst is number of runs allowed to start in the given window, in a single burst,
	// before throttling applies.
	//
	// A burst > 1 bypasses smoothing for the burst and allows many runs to start
	// at once, if desired.  Defaults to 1, which disables bursting.
	Burst uint `json:"burst"`
	// Key is an optional string to constrain throttling using event data.  For
	// example, if you want to throttle incoming notifications based off of a user's
	// ID in an event you can use the following key: "event.user.id".  This ensures
	// that we throttle functions for each user independently.
	Key *string `json:"key,omitempty"`
}

type RateLimit struct {
	// Limit is how often the function can be called within the specified period
	Limit uint `json:"limit"`
	// Period represents the time period for throttling the function
	Period time.Duration `json:"period"`
	// Key is an optional string to constrain rate limiting using event data.  For
	// example, if you want to rate limit incoming notifications based off of a user's
	// ID in an event you can use the following key: "event.user.id".  This ensures
	// that we rate limit functions for each user independently.
	Key *string `json:"key,omitempty"`
}

// Timeouts represents timeouts for the function. If any of the timeouts are hit, the function
// will be marked as cancelled with a cancellation reason.
type Timeouts struct {
	// Start represents the timeout for starting a function.  If the time between scheduling
	// and starting a function exceeds this value, the function will be cancelled.  Note that
	// this is inclusive of time between retries.
	//
	// A function may exceed this duration because of concurrency limits, throttling, etc.
	Start *time.Duration `json:"start,omitempty"`

	// Finish represents the time between a function starting and the function finishing.
	// If a function takes longer than this time to finish, the function is marked as cancelled.
	// The start time is taken from the time that the first successful function request begins,
	// and does not include the time spent in the queue before the function starts.
	//
	// Note that if the final request to a function begins before this timeout, and completes
	// after this timeout, the function will succeed.
	Finish *time.Duration `json:"finish,omitempty"`
}
